\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb, amsthm, csc, mathbbol}
\usepackage{float}
\usepackage{amsfonts}
\usepackage{mathtools}
\usepackage{listings}
\usepackage{multicol}
\usepackage{enumerate}
\usepackage{titlesec}
\usepackage{tikz}
\usetikzlibrary{arrows.meta,positioning}

\usepackage{graphicx}
\usepackage{fullpage}
\usepackage{comment}
\usepackage{color}
\usepackage[mathscr]{euscript}
\let\euscr\mathscr \let\mathscr\relax
\usepackage[scr]{rsfso}
\newcommand{\powerset}{\raisebox{.15\baselineskip}{\Large\ensuremath{\wp}}}
\newcommand{\myiff}{\mbox{ iff }}

\usepackage[a4paper, margin=1in]{geometry}
\newtheorem{ques}{Question}[section]
\newtheorem{defs}{Definition}[section]
\newenvironment{question}{
    \begin{ques} \normalfont
    }{
    \end{ques}
}

\newenvironment{shiftpar}[1][1.5em]
  {\list{}{%\listparindent #1%
    \itemindent\parindent
    \leftmargin#1
%    \rightmargin\leftmargin
    \parsep\z@\@plus\p@}%
    \item\relax}
  {\endlist}
  
\newenvironment{my_enumerate}{
\begin{enumerate}
  \setlength{\itemsep}{-1pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}}{\end{enumerate}
}

\newtheorem{claimS}{Claim}[subsection]
\newtheorem{claims}{Claim}[claimS]



\newcommand{\fdent}{\hspace{4mm}}
\titleformat*{\subsection}{\normalfont}
\newcommand{\AAND}{\; AND\;}
\newcommand{\OOR}{\; OR\;}

\newcommand*{\myfontforfunc}{\fontfamily{bch}\selectfont}
\DeclareTextFontCommand{\textfunc}{\myfontforfunc}

\lstset
{ %Formatting for code in appendix
    basicstyle=\footnotesize,
    numbers=left,
    stepnumber=1,
    showstringspaces=false,
    tabsize=1,
    breaklines=true,
    breakatwhitespace=false,
}
\renewcommand{\thesubsection}{\thesection.\alph{subsection}}


\title{CSC373 Assignment 4}
\author{Haoda Li, Ruiqi Wang, Zonggen Bai}

\begin{document}
\maketitle
\begin{enumerate}
\item \textbf{Algorithm} 
\begin{enumerate}
    \item For each $j\in\mathbb{Z}^+. j\leq n$, assign $s_j = c_j - \sum_{i=1}^m d_{i,j}$. 
    \item Define the integer linear programming such that
    \begin{itemize}
        \item Variables: \[
        X_j= 
        \begin{cases}
            1 & \text{if } j \text{th tool is purchased} \\
            0 & \text{otherwise}
        \end{cases}
        \]
        \item Objective functions: minimize $\sum_{j=1}^n s_jX_j$
        \item Constraint: for each pair of incompatible tools $p,q$, $X_p + X_q \in \{0,1\}$
    \end{itemize}
    \item return $S = \{j\in\mathbb{Z^+}\mid X_j = 1\}$
\end{enumerate}

\textbf{Correctness} \\
Claim. The total cost is minimized by purchasing all tools in $S$ and $S$ does not contain any incompatible tools. 
\begin{proof}
Let $S'$ be an arbitrary set of tools. The total cost $T$ to complete the jobs will be 
\begin{align*}
    T &=\sum_{i=1}^m\sum_{j=1}^n d_{i,j} + \sum_{j\in S'} c_j - \sum_{i=1}^m\sum_{j\in S'} d_{i,j} \\
    &=\sum_{i=1}^m\sum_{j=1}^n d_{i,j} +  \sum_{j\in S'}\{c_j - \sum_{i=1}^m d_{i,j}\} \\
    &=\sum_{i=1}^m\sum_{j=1}^n d_{i,j} +  \sum_{j\in S'} s_j \text{ by the definition of } s
\end{align*} 
Because $\sum_{i=1}^m\sum_{j=1}^n d_{i,j}$ is a constant, minimize $T$ is equivalent to minimize $\sum_{j\in S'} s_j$. 
Because $\sum_{j\in S} s_j = \sum_{j=1}^m s_jX_j$ is minimized in the linear programming, the total cost is minimized. \\

Then, I'll show that there is no incompatible tools in $S$. \\
Suppose exists tools $p,q\in S$ that are incompatible, then $X_p+X_q = 2$ since they are both in $S$, while it contradicts with the constraint $X_p + X_q \in\{0,1\}$ for each pair of incompatible tools. Therefore, $S$ does not contain incompatible tools. 

\end{proof}
\newpage
\item Define $w(c)$ be the total weight of edges in a set of edges $c$
\begin{enumerate}
    \item Claim. $ASC\in coNP$. \\
    Define the verifier:
    \begin{lstlisting}
    verify(G, s, B, c):
        return (c is a cycle in G and c starts with s and w(c) > B)
    \end{lstlisting}
    Generate-and-verify algorithm:
    \begin{lstlisting}
    On input (G, s, B):
        for each subset of edges c:
            if verify(G, s, B, c):
                return False
        return True
    \end{lstlisting}
    \textbf{verify runs in polynomial time} \\
    For each certificate $c$, $verify(G, s, B, c)$ runs in $O(|E|)$ time since a subset of edges of G cannot have more than $|E|$ edges. For each edge in c, it is constant to check whether the edge is in G (i.e. a total of $\mathcal{O}(|E|)$). It is $\mathcal{O}(|E|)$ to check if $c$ is a cycle starting with s. It is also $\mathcal{O}(|E|)$ to sum up the weight of each edge to get $w(c)$.  
    
    \textbf{algorithm is correct}\\
    Let $G\not\in ASC$ then we can find some $c$ such that $w(c)>B$, hence $verify(G, s, B, c)$ will return true for this $c$ and the algorithm will return false. \\ 
    Let $G \in ASC$, $G$ cannot have a cycle that starts with $s$ and $w(C)> B$, then $verify(G, s, B, c)=False$ for all certificate $c$ and the algorithm will return true.\\
    
    \item Claim. $ALC\in P$. \\
    \textbf{Algorithm} 
    \begin{enumerate}
        \item run Shortest Path-All Pairs (dynamic) algorithm on $G'=(V',E')$ where \\ 
        $V'=V-\{s\}, E'=E-\{e\in E\mid e \text{ have one endpoint being }s\}$.
        \item find $d = \min\{w(s,u) + w(s,v) + w(P^*(u,v))\mid (s,u)\in E \land (s,v)\in E \land \text{there exists path between } u,v \text{ in }G', u\neq v\}$ where $w(P^*(u,v))$ is the weight of the shortest path between $u,v$ in $G'$
        \item return $d\geq B$
    \end{enumerate}
\textbf{Correctness} \\
Claim. $d$ is the minimum weight of cycles in $G$ that starts at $s$.
\begin{proof}
Let $C$ in $G$ that starts at $s$ and $w(C)=d$. \\
Suppose $d$ is not the minimum, then take a cycle $C'$ in G that starts at $s$ and $w(C')<d$. Consider $(s,u), (s,v)\in C'$. Then $w(C') = w(s,u) + w(s,v) + w(P(u,v))$, where $P(u,v)$ is the path between $u,v$ in $C$ and does not include $s$. \\
Since $w(s,u)+w(s,v)+w(P(u,v)) < w(s,u)+w(s,v)+w(P^*(u,v))$, then $w(P(u,v))<w(P^*(u,v))$ contradict with the fact that $w(P^*(u,v))$ is the shortest path in $G'$.
\end{proof}

Corollary. If $d \geq B$, then every cycle in G that starts at vertex s have total weight at least $B$.

\textbf{Runtime} \\
For step i, get $G'$ and the shortest path - all pairs algorithm runs in polynomial time. For step ii, the number of pairs of different $u,v$ that are adjacent to $s$ is in $O(|V|^2)$ and computing the weight is constant, hence the total run time of finding minimum is in $O(|V|^2)$, and step iii takes constant time. Therefore, the total runtime is in polynomial time. 

Therefore, $ALC\in P$\\


\item Claim. SLC $\in NP$.\\
        Define the verifier:
    \begin{lstlisting}
    verify(G, s, B, c):
        return c is a cycle in G and c starts at s and w(c) >= B
    \end{lstlisting}
    Generate-and-verify algorithm:
    \begin{lstlisting}
    On input (G, s, B):
        for each subset of edges c:
            if verify(G, s, B, c):
                return True
        return False
    \end{lstlisting}
    \textbf{verify runs in polynomial time} \\
    Similar to (a), for each certificate $c$, $verify(G, s, B, c)$ runs in $O(|E|)$ time since a subset of edges $c$ cannot have more than $|E|$ edges. Checking whether each edge of $c$ is in $G$ takes constant time and a total of $\mathcal{O}(|E|)$ time. It is also $\mathcal{O}(|E|)$ to sum up the weights of the edges in $c$ to get $w(c)$. 
    
    \textbf{algorithm is correct}\\
    Let $G \in SLC$ then we can find some $c$ such that $w(c) >= B$, hence $verify(G, s, B, c)$ will return true and the algorithm will return true. \\ 
    Let $G \not\in SLC$, $G$ cannot have a cycle that starts with $s$ and $w(C)>= B$, then $verify(G, s, B, c)=False$ for all certificate $c$,  and the algorithm will return false.\\
    
    \item Claim. SSC $\in P$.\\
    \textbf{Algorithm} 
    \begin{enumerate}
    \item Run Dijkstra's Algorithm on vertex s until all of the vertices have been visited
    \item For each pair of vertices u,v connected to s:
        \begin{itemize}
            \item Run Dijkstra's Algorithm to find shortest path from u to v in $G'=(V',E')$ where $V'=V-\{s\}, E'=E-\{e\in E\mid e \text{ have one endpoint being }s\}$.
            \item If $d = P(u,v) + w(s,u) + w(s,v) \leq B$ where $P(u,v)$ is the weight of the shortest path between u and v then: return True
        \end{itemize}
    \item return False
    \end{enumerate}
    \textbf{Correctness} \\
    Claim. $d$ is the minimum weight among the cycles that include vertices $u$, $v$ and $s$.
    \begin{proof}
    Suppose there is a cycle $c'$ with weight $d'$ such that weight of $c'$ is less than $c$, the cycle whose weight is $d$. Since $d = w(s,u) + w(s,v) + P(u,v)$ and $d' < d$, there are three cases:
    \begin{enumerate}
        \item $w'(s,u) < w(s,u)$
        \item $w'(s,v) < w(s,v)$
        \item $P'(u,v) < P(u,v)$
    \end{enumerate}
    However, it contradicts with the fact that $w(s,u)$, $w(s,v)$ and $P(u,v)$ are minimum, given by the Dijkstra's Algorithm. Therefore, $d$ is the minimum weight among the cycles that include vertices $u$, $v$ and $s$.\\
    Therefore, if the algorithm checks all of the minimum weights of the cycles starting at vertex $s$, it will find the cycle with total weight no more than $B$ if there is one.
    \end{proof}
    \textbf{Runtime} \\
    First Dijkstra's Algorithm takes time $O(|E|log(|V|))$, which is in ploytime. There are $O(|V|^2)$ pairs of $u$ and $v$ and for each of them running another Dijkstra's Algorithm takes time $O(|E|log(|V|))$. Then the for loop takes time $O(|E|\cdot |V|^2log(|V|))$ in worst case. Therefore, the algorithm takes polytime in total.
    
    Hence, $SSC\in P$\\
    
\end{enumerate}

\item
\begin{enumerate}
    \item Let $D_1, D_2, D_3$ be three decision problems, assume $D_1\rightarrow_p D_2$, $D_2\rightarrow_p D_3$. WTS $D_1\rightarrow_p D_3$.
    \begin{proof}
         Let $I_1$ = $\{$all inputs to $D_1\}$, $I_2$ = $\{$all inputs for $D_2\}$.Since $D_1\rightarrow_p D_2$, then there is a function $f: I_1\rightarrow I_2$ computable in polynomial time s.t. $\forall x \in I_1$, $x \in D_1$ iff $f(x) \in D_2$.\\
         Let $I_3$ = $\{$all inputs to $D_3\}$. Since $D_2\rightarrow_p D_3$, then there is a function $g: I_2\rightarrow I_3$ computable in polynomial time s.t. $\forall y \in I_2$, $y \in D_2$ iff $g(y) \in D_3$.\\
         Let $h = g \circ f$, $h: I_1 \rightarrow I_3$, then $\forall x \in I_1$, $x \in D_1$ iff $f(x) \in D_2$ and $f(x) \in D_2$ iff $g(f(x)) \in D_3$. Thus,  $x \in D_1 $ iff $h(x) \in D_3$.\\
         Also, the runtime of $h$ is the runtime of $f$ on $I_1$ $+$ the runtime of $g$ on $f(I_1)$. Since $f$ is computable in polynomial time w.r.t. the size of $I_1$, the size of $f(I_1)$ is also a polynomial of $I_1$. Since $g$ is computable in polynomial time w.r.t. the size of $I_2$, it is computable in polynomial time w.r.t. the size of $f(I_1)$, and thus computable in polynomial time w.r.t. the size of $I_1$. Therefore, $h$ is computable in polynomial time w.r.t. the size of $I_1$.\\
         From above, we can conclude that $D_1 \rightarrow_p D_3$. 
    \end{proof}
    \item Claim. $D$ is NP-complete.
    \begin{proof}
        First show that $D$ is NP.\\
        Since $D'$ is NP-complete, $D'$ is NP. Since $D \rightarrow_p D'$, then D is also NP.\\
        Next show that $D$ is NP-hard.\\
        Let $D''$ be a NP problem. Since $D'$ is NP-complete, then $D'' \rightarrow_p D'$. Since $D' \rightarrow_p D$, then by transitivity, $D'' \rightarrow_p D$.\\
        Therefore, $\forall$ NP-problem $D''$, $D'' \rightarrow_p D$, i.e. $D$ is NP-hard.\\
        From above, can conclude that $D$ is NP-complete.
    \end{proof}
    
    \item Claim. $NP = coNP$.
    \begin{proof}
        i. First show $NP \subset coNP$.\\
        Since $D$ is NP-complete, let $D' \in NP$, then $D' \rightarrow_p D$. Since $D \in coNP$, then $D' \in coNP$. Thus, $\forall D' \in NP, D' \in coNP$, i.e. $NP \subset coNP$.\\
        
        ii. Next show $coNP \subset NP$.\\
        $lemma: $ Let A, B be two decision problems. If $A \rightarrow_p B$, then $\overline{A} \rightarrow_p \overline{B}$, where $\overline{A}$ is the complement of $A$, $\overline{B}$ is the complement of B.\\
        Proof of lemma:  Let $I_A$ = $\{$all inputs to A$\}$, $I_B$ = $\{$all inputs for $B\}$.\\
        Assume $A \rightarrow_p B$, then there is a function $f$ computable in polynomial time, s.t. $x \in I_A \Longleftrightarrow f(x) \in I_B$. Then $f(x) \not\in I_B \Rightarrow x \not\in I_A$ (follows from $x\in I_A \Rightarrow f(x) \in I_B$), and $x \not\in I_A \Rightarrow f(x) \not\in I_B$ (follows from $f(x)\in I_B \Rightarrow x\in I_A$).\\
        i.e. $x \not\in I_A \Longleftrightarrow f(x) \not\in I_B$.\\
        Therefore, there exists function f computable in polynomial time, s.t. $x \in \overline{I_A} \Longleftrightarrow f(x) \in \overline{I_B}$. i.e. $\overline{A} \rightarrow_p \overline{B}$\\[2ex]
        Proof for (ii). Let $D_c \in coNP$, then $\overline{D_c} \in NP$. Since $D$ is NP-complete, we know $\overline{D_c} \rightarrow_p D$. Then by the lemma above, $D_c \rightarrow_p \overline{D}$. Since $\overline{D} \in NP$, then $D_c \in NP$. Thus, we have $\forall D_c \in coNP, D_c \in NP$, i.e. $coNP \subset NP$.\\[2ex]
        From (i)(ii), we can conclude that $NP = coNP$.
    \end{proof}
\end{enumerate}

\end{enumerate}


\end{document}
